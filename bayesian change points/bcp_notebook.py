# -*- coding: utf-8 -*-
"""BCP_notebook.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1poKkVNpFu4lykt90JU2FChJfuYQDa3gi
"""

# Commented out IPython magic to ensure Python compatibility.
import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
# %matplotlib inline
import pymc3 as pm

from matplotlib import cycler

df_raw = pd.read_csv('C:\\Users\\G40394135\\Downloads\\battery_B5.csv')

# Extract the capacity and datetime columns
capacity = df_raw['capacity'].values
cycles = df_raw['cycle'].values

colors = cycler('color',
                ['#EE6666', '#3388BB', '#9988DD',
                 '#EECC55', '#88BB44', '#FFBBBB'])
plt.rc('axes', facecolor='#E6E6E6', edgecolor='none',
       axisbelow=True, grid=True, prop_cycle=colors)
plt.rc('grid', color='w', linestyle='solid')
plt.rc('xtick', direction='out', color='gray')
plt.rc('ytick', direction='out', color='gray')
plt.rc('patch', edgecolor='#E6E6E6')
plt.rc('lines', linewidth=2)

plt.plot(df_raw['cycle'], df_raw['capacity'], "*")
plt.ylabel("Capacity in Ahr")
plt.xlabel("Cycle number")

drastic_change_threshold = 0.5

with pm.Model() as disaster_model:  # Context manager to wrap all values
    switchpoint = pm.DiscreteUniform("switchpoint", lower=cycles.min(), upper=cycles.max(), testval=10)

    # Priors for pre- and post-switch means and standard deviations
    early_mean = pm.Normal("early_mean", mu=np.mean(capacity), sigma=10)
    late_mean = pm.Normal("late_mean", mu=np.mean(capacity), sigma=10)
    
    early_std = pm.HalfNormal("early_std", sigma=5)
    late_std = pm.HalfNormal("late_std", sigma=5)

    # Allocate appropriate Gaussian parameters to cycles before and after the switchpoint
    mu = pm.math.switch(switchpoint >= cycles, early_mean, late_mean)
    sigma = pm.math.switch(switchpoint >= cycles, early_std, late_std)

    # Likelihood of observed capacities given the Gaussian distribution
    capacity_obs = pm.Normal("capacity_obs", mu=mu, sigma=sigma, observed=capacity)

with disaster_model:
    trace = pm.sample(200)

pm.traceplot(trace, combined=False, compact=False)

# Extract samples for means and standard deviations
early_mean_samples = trace['early_mean']
late_mean_samples = trace['late_mean']
mean_diff = late_mean_samples - early_mean_samples

# Extract switchpoint samples from trace
switchpoint_samples = trace['switchpoint']

# Get unique switchpoint values (since switchpoint is discrete)
unique_switchpoints = np.unique(switchpoint_samples)

drastic_switchpoints = []
# Print or use each individual switchpoint value
for switchpoint_value in unique_switchpoints:
    idx = np.where(switchpoint_samples == switchpoint_value)[0]
    mean_rate_diff = np.mean(mean_diff[idx])

    if abs(mean_rate_diff) >= drastic_change_threshold:
        drastic_switchpoints.append(switchpoint_value)

for switchpoint_value in drastic_switchpoints:
    print(f"Drastic switchpoint occurred at cycle number: {switchpoint_value}")

df = pd.DataFrame({'changepoint': drastic_switchpoints})

# Save DataFrame to a CSV file
csv_filename = 'drastic_changepoints.csv'
df.to_csv(csv_filename, index=False)
